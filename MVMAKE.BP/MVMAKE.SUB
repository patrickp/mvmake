    SUBROUTINE MVMAKE.SUB(CMND)

    IF CMND=0 THEN STOP

    CRT CMND

    PRINT "1.1"
    PLATFORM=FIELD(CMND,' ',2)
    MVTYPE=FIELD(CMND,' ',3)
    PACKAGE.NAME=FIELD(CMND,' ',4)
    PASSED.PACKAGE=PACKAGE.NAME
    PACKAGE.PATH=FIELD(CMND,' ',5)

    CRT "PACKAGE.PATH=":PACKAGE.PATH


    IF PLATFORM = "" THEN
        PRINT "ENTER PLATFORM (LINUX OR WINDOWS): ":; INPUT PLATFORM
    END

    PLATFORM=OCONV(PLATFORM,"MCU")

    BEGIN CASE
    CASE PLATFORM="WINDOWS"
        D3.PREFIX="dos"
        PLATFORM.DELIM="\"
    CASE PLATFORM="LINUX"
        D3.PREFIX="unix"
        PLATFORM.DELIM="/"
    CASE 1
        STOP "Invalid Platform ":PLATFORM
    END CASE

    IF MVTYPE="" THEN
        PRINT "ENTER MVTYPE (JBASE, QM, D3, UNIVERSE, UNIDATA) ":; INPUT MVTYPE
    END

    MVTYPE=OCONV(MVTYPE,"MCU")

    BEGIN CASE
        CASE MVTYPE="JBASE"
        CASE MVTYPE="QM"
        CASE MVTYPE="D3"
        CASE MVTYPE="UNIVERSE"
        CASE MVTYPE="UNIDATA"
        CASE 1
            STOP "Invalid MVTYPE"
    END CASE

*
    OPEN "MD" TO FILE.MD ELSE
        OPEN "VOC" TO FILE.MD ELSE STOP "Could not find MD or VOC"
    END

    IF PACKAGE.NAME = "" THEN
        PRINT "Enter package name: ":; INPUT PACKAGE.NAME
    END

    IF PACKAGE.PATH = "" THEN
        PRINT "Enter path to package (":PACKAGE.PATH:") ":; INPUT TMP.INPUT
        IF TMP.INPUT # "" THEN PACKAGE.PATH=TMP.INPUT
    END
    * LETS CREATE THE PLATFORM.JSON FILE IF IT DOES NOT EXIST

    READ MV.PLATFORM.JSON FROM FILE.MD, "MV.PLATFORM.JSON" ELSE
        JSON='{ "platform": "':PLATFORM:'", "mvtype": "':MVTYPE:'" }'
        WRITE JSON ON FILE.MD, "MV.PLATFORM.JSON"
    END
    
    MD.NAME = OCONV(PACKAGE.NAME,"MCU"):".BP"

    READ MD.ITEM FROM FILE.MD, MD.NAME ELSE MD.ITEM=""
    IF MD.ITEM # "" THEN STOP "MD Item aleady exists"

    BEGIN CASE
    CASE MVTYPE="D3"
* ON D3 WE NEED A PICK FILE FOR OUR ROOT
        EXECUTE "CREATE-FILE DICT ":MD.NAME:" 11"
        OPEN "DICT",MD.NAME TO FILE.DICT ELSE STOP "COULD NOT OPEN DICT ":MD.NAME
        ROOT.MD.ITEM="Q"
        ROOT.MD.ITEM<3>=D3.PREFIX:":":PACKAGE.PATH
        WRITE ROOT.MD.ITEM ON FILE.MD, MD.NAME:'.ROOT'
        ROOT.MD.ITEM<3>=D3.PREFIX:":":PACKAGE.PATH:PLATFORM.DELIM:MD.NAME
        SAVE.MD.ITEM=ROOT.MD.ITEM
        WRITE ROOT.MD.ITEM ON FILE.DICT, MD.NAME
        ROOT.NAME=MD.NAME:".ROOT"
    CASE MVTYPE="UNIDATA"
* ON UNIDATA WE NEED A PICK FILE FOR OUR ROOT
        EXECUTE "CREATE-FILE DICT ":MD.NAME:" 11"
        READ MD.ITEM FROM FILE.MD, MD.NAME ELSE STOP "VOC ENTRY FOR ":MD.NAME:" NOT CREATED"
        SAVE.MD.ITEM=MD.ITEM
        MD.DICT.NAME=MD.ITEM<3>
        MD.ITEM<1>="DIR"
        MD.ITEM<2>=PACKAGE.PATH:"/":MD.NAME
        WRITE MD.ITEM ON FILE.MD, MD.NAME
* NOW LETS WRITE OUT A ROOT ENTRY
        ROOT.MD.ITEM=MD.ITEM
        ROOT.MD.ITEM<2>=PACKAGE.PATH
        WRITE ROOT.MD.ITEM ON FILE.MD, MD.NAME:'.ROOT'
        ROOT.NAME=MD.NAME:".ROOT"
    CASE MVTYPE="QM"
        MD.ITEM="F"
        MD.ITEM<2>=PACKAGE.PATH:PLATFORM.DELIM:MD.NAME
        MD.ITEM<3>=PACKAGE.PATH
        MD.ITEM<4>=MD.NAME
        * NOW LETS ADD THE SECOND BP.OUT DIRECTORY
        *MD.ITEM<2,2>=PACKAGE.PATH:PLATFORM.DELIM:MD.NAME:'.O'
        *MD.ITEM<4,2>="BP.OUT"
        WRITE MD.ITEM ON FILE.MD, MD.NAME
        SAVE.MD.ITEM=MD.ITEM
        ROOT.NAME="DICT " :MD.NAME
    CASE 1
        MD.ITEM="F"
        MD.ITEM<2>=PACKAGE.PATH:"/":MD.NAME
        MD.ITEM<3>=PACKAGE.PATH
        WRITE MD.ITEM ON FILE.MD, MD.NAME
        SAVE.MD.ITEM=MD.ITEM
        ROOT.NAME="DICT " :MD.NAME
    END CASE

    OPEN ROOT.NAME TO FILE.ROOT ELSE STOP "COULD NOT OPEN ":ROOT.NAME

    READ PACKAGE.MV FROM FILE.ROOT, "PACKAGE.MV" ELSE STOP "NO PACKAGE.MV IN ROOT DIR OF PACKAGE"

    NUM.ENTRIES=DCOUNT(PACKAGE.MV,@AM)

    FOR L=1 TO NUM.ENTRIES
        ENTRY=PACKAGE.MV<L>
        COMMAND=OCONV(ENTRY<1,1>,"MCU")
        PRINT COMMAND
        BEGIN CASE
            CASE COMMAND="DIRECTORY"; GOSUB build.directory
            CASE COMMAND="BASIC"; GOSUB compile.code
            CASE TRIM(COMMAND)="" ;* DO NOTHING
            CASE 1; CRT "INVALID COMMAND ":COMMAND
            CASE TRIM(COMMAND)="" ;* DO NOTHING
        END CASE
    NEXT L

    RETURN

build.directory:    *

    DIRECTORY.NAME=ENTRY<1,2>
    DIRECTORY.DIR.NAME=ENTRY<1,3>
    IF DIRECTORY.DIR.NAME="" THEN DIRECTORY.DIR.NAME=DIRECTORY.NAME

    * 1/19/2020 PAP Modified this to allow {PLATFORM} to be part of the directory path.  This is for dependency sub directory includes
    
    IF INDEX(DIRECTORY.DIR.NAME,'{PLATFORM}',1) THEN
        POS=INDEX(DIRECTORY.DIR.NAME,'{PLATFORM}',1)
        PRE.DIR=DIRECTORY.DIR.NAME[1,POS-1]
        AFT.DIR=DIRECTORY.DIR.NAME[POS+10,LEN(DIRECTORY.DIR.NAME)]
        DIRECTORY.DIR.NAME=PRE.DIR:MVTYPE:AFT.DIR
    END
    *IF DIRECTORY.DIR.NAME="{PLATFORM}" THEN DIRECTORY.DIR.NAME=MVTYPE

    * 1/19/2020 PAP Cludge to adjust any directory paths to platform delimim
    
    CONVERT '\' TO PLATFORM.DELIM IN DIRECTORY.DIR.NAME
    CONVERT '/' TO PLATFORM.DELIM IN DIRECTORY.DIR.NAME

    CRT "Mapping directory for ":DIRECTORY.NAME:" ":
    BEGIN CASE
    CASE MVTYPE="D3"
        EXECUTE 'CREATE-FILE DICT ':MD.NAME:'.':DIRECTORY.NAME:' 11'
        OPEN 'DICT',MD.NAME:'.':DIRECTORY.NAME TO FILE.DICT ELSE STOP "COULD NOT OPEN ":MD.NAME:'.':DIRECTORY.NAME
        SUB.MD.ITEM=SAVE.MD.ITEM
        SUB.MD.ITEM<3>=D3.PREFIX:':':PACKAGE.PATH:PLATFORM.DELIM:DIRECTORY.DIR.NAME
        SUB.NAME=MD.NAME:'.':DIRECTORY.NAME
        WRITE SUB.MD.ITEM ON FILE.DICT, SUB.NAME
        CLOSE FILE.DICT
    CASE MVTYPE="JBASE"       ;* NOTHING
        *SUB.NAME=MD.NAME:",":DIRECTORY.NAME
        * DECIDING TO KEEP THINGS CONSISTENT
        SUB.MD.ITEM=SAVE.MD.ITEM
        SUB.MD.ITEM<2>=PACKAGE.PATH:PLATFORM.DELIM:DIRECTORY.DIR.NAME
        SUB.NAME=MD.NAME:'.':DIRECTORY.NAME
        WRITE SUB.MD.ITEM ON FILE.MD, SUB.NAME
    CASE MVTYPE="QM"
        SUB.MD.ITEM=SAVE.MD.ITEM
        SUB.MD.ITEM<2>=PACKAGE.PATH:PLATFORM.DELIM:DIRECTORY.DIR.NAME
        SUB.MD.ITEM<3>=PACKAGE.PATH
        SUB.MD.ITEM<4>=MD.NAME:'.':DIRECTORY.NAME
        * ADD A BP.OUT JUST FOR FUN
        *SUB.MD.ITEM<2,2>=PACKAGE.PATH:PLATFORM.DELIM:DIRECTORY.DIR.NAME:PLATFORM.DELIM:"BP.OUT"
        *SUB.MD.ITEM<4,2>="BP.OUT"
        SUB.NAME=MD.NAME:'.':DIRECTORY.NAME
        WRITE SUB.MD.ITEM ON FILE.MD, SUB.NAME
    CASE MVTYPE="UNIVERSE" OR MVTYPE="QM"
        SUB.MD.ITEM=SAVE.MD.ITEM
        SUB.MD.ITEM<2>=PACKAGE.PATH:PLATFORM.DELIM:DIRECTORY.DIR.NAME
        SUB.NAME=MD.NAME:'.':DIRECTORY.NAME
        WRITE SUB.MD.ITEM ON FILE.MD, SUB.NAME
    CASE MVTYPE="UNIDATA"
* CREATE ANOTHER VOC ENTRY FOR THIS FILE
        SUB.MD.ITEM=SAVE.MD.ITEM
        SUB.MD.ITEM<1>="DIR"
        SUB.MD.ITEM<2>=PACKAGE.PATH:PLATFORM.DELIM:DIRECTORY.DIR.NAME
        SUB.NAME=MD.NAME:'.':DIRECTORY.NAME
        WRITE SUB.MD.ITEM ON FILE.MD, SUB.NAME
    END CASE

    PRINT "(":SUB.NAME:") ":
    OPEN SUB.NAME TO FILE.SUB.NAME ELSE
        STOP "Failed"
    END
    CLOSE FILE.SUB.NAME
    PRINT "OK"

    RETURN

compile.code: *

DIRECTORY=ENTRY<1,2>
COMPILE.LIST.ID=ENTRY<1,3>

PRINT
PRINT '----------------------------------------------------------------------'
PRINT 'COMPILE ':DIRECTORY:' ':COMPILE.LIST.ID:' ':
OPEN DIRECTORY TO BP.DIRECTORY ELSE
    PRINT 'COULD NOT OPEN ':DIRECTORY:' TO DO COMPILE'
    STOP
END
READ COMPILE.LIST FROM BP.DIRECTORY, COMPILE.LIST.ID ELSE
    PRINT "COULD NOT FIND ":COMPILE.LIST.ID:" IN ":DIRECTORY
    RETURN
END
CONVERT CHAR(10) TO '' IN COMPILE.LIST
CONVERT CHAR(13) TO @AM IN COMPILE.LIST

PRINT DCOUNT(COMPILE.LIST,@AM)

NUM.BP.ITEMS=DCOUNT(COMPILE.LIST,@AM)

FOR BP.CNTR=1 TO NUM.BP.ITEMS
    BP.ITEM.NAME=COMPILE.LIST<BP.CNTR>
    PLATFORM.SPECIFIC=0
    IF INDEX(BP.ITEM.NAME,"{PLATFORM}",1) THEN
        POS=INDEX(BP.ITEM.NAME,'{PLATFORM}',1)
        PRE.BP.ITEM.NAME=BP.ITEM.NAME[1,POS-1]
        AFT.BP.ITEM.NAME=BP.ITEM.NAME[POS+10,9999]
        BP.ITEM.NAME=PRE.BP.ITEM.NAME:MVTYPE:AFT.BP.ITEM.NAME
        PLATFORM.SPECIFIC=1
    END
    PRINT ' ':BP.ITEM.NAME"ML(#60)":' ':
    NO.ITEM=0
    READ TEST FROM BP.DIRECTORY, BP.ITEM.NAME ELSE NO.ITEM=1
    IF NO.ITEM THEN
        IF PLATFORM.SPECIFIC THEN
            PRINT "Skipping"
        END ELSE
            PRINT "Missing"
        END
    END ELSE
        BASIC.CMND=''
        CATALOG.CMND=''
        BASIC.RESULT=''
        CATALOG.RESULT=''
        BEGIN CASE
            CASE MVTYPE='JBASE'
                BASIC.CMND="BASIC ":DIRECTORY:" ":BP.ITEM.NAME
                BASIC.RESULT='compiled successfully'
                CATALOG.CMND="CATALOG ":DIRECTORY:" ":BP.ITEM.NAME
                CATALOG.RESULT='cataloged successfully'
            CASE MVTYPE='D3'
                BASIC.CMND=":ccompile ":DIRECTORY:" ":BP.ITEM.NAME
                BASIC.RESULT="Successful"
                CATALOG.CMND="CATALOG ":DIRECTORY:" ":BP.ITEM.NAME
                CATALOG.RESULT="Cataloged"
            CASE MVTYPE='UNIDATA'
            CASE MVTYPE='UNIVERSE'
                BASIC.CMND="BASIC ":DIRECTORY:" ":BP.ITEM.NAME
                BASIC.RESULT="Complete"
                CATALOG.CMND="CATALOG ":DIRECTORY:" ":BP.ITEM.NAME:" FORCE"
                CATALOG.RESULT="cataloged"
            CASE MVTYPE='QM'
                BASIC.CMND="BASIC ":DIRECTORY:" ":BP.ITEM.NAME
                BASIC.RESULT="0 error"
                CATALOG.CMND="CATALOG ":DIRECTORY:" ":BP.ITEM.NAME
                CATALOG.RESULT="added to"
            CASE 1; PRINT 'Invalid platform!!'
        END CASE

        IF BASIC.CMND # "" THEN
            EXECUTE BASIC.CMND CAPTURING RESULT
            IF INDEX(RESULT,BASIC.RESULT,1) THEN
                PRINT '  Compiled ':
                EXECUTE CATALOG.CMND CAPTURING RESULT
                IF INDEX(RESULT,CATALOG.RESULT,1) THEN
                    PRINT '  Cataloged!'
                END ELSE
                    PRINT '  Catalog failed!! ':RESULT
                END
            END ELSE
                PRINT '  Compile Failed!! ':RESULT
            END
        END
    END

NEXT BP.CNTR


RETURN
